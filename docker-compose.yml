# Define uma âncora YAML com configurações comuns para reutilização
x-common-config: &common-config
  env_file:
    - .env

services:
  # --- SERVIÇO DE PRODUÇÃO (padrão) ---
  scraper:
    <<: *common-config # Reutiliza a configuração comum
    build:
      context: .
      dockerfile: Dockerfile.prod
    container_name: assectra_scraper
    # Em produção, não mapeamos o código-fonte. Ele já está "assado" na imagem.
    # Mapeamos apenas a pasta de saída.
    volumes:
      - ./config:/usr/src/app/config
      - ./output:/usr/src/app/output

  # --- SERVIÇO DE DESENVOLVIMENTO (ativado com --profile dev) ---
  # Pesquisar mais sobre uso de profiles com compose em = https://docs.docker.com/compose/how-tos/profiles/
  scraper-dev:
    <<: *common-config # Reutiliza a configuração comum
    profiles:
      - dev
    build:
      context: .
      dockerfile: Dockerfile.dev
    container_name: assectra_scraper_dev
    # O comando padrão para o serviço de desenvolvimento.
    # Ele fica esperando para sempre, permitindo que você use 'docker compose exec'.
    # Usar 'tail -f /dev/null' mantém o container rodando sem executar um script,
    # o que é ideal para executar tarefas sob demanda com 'docker compose run'.
    command: tail -f /dev/null
    volumes:
      # Mapeia todo o diretório do projeto para o diretório de trabalho no container.
      # Isso garante que alterações em QUALQUER arquivo (package.json, .babelrc, src/*)
      # sejam refletidas instantaneamente.
      - .:/usr/src/app
      # Esta linha é um "truque" para evitar que a pasta node_modules local
      # (que pode não existir ou ser para outro SO) sobrescreva a pasta
      # node_modules que foi instalada pelo `RUN npm ci` no Dockerfile.
      - /usr/src/app/node_modules
